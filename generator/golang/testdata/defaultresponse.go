// Automatically generated by Jenny. DO NOT EDIT!

// Package v3 as generated by Jenny
// Please read about it
package v3

import (
	"context"
	"fmt"
	"net/http"
	"os/user"
	"strconv"

	"github.com/jennyservices/jenny/decoders"
	"github.com/jennyservices/jenny/encoders"
	"github.com/jennyservices/jenny/options"
	"github.com/go-kit/kit/endpoint"
	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
)

// TestService3 as generated by Jenny
// Please read more at
type TestService3 interface {
	GetUser(ctx context.Context, First int, User user.User, ID *int) (err error)

	Login(ctx context.Context) (Body *user.User, err error)
}

// _getUserRequest is not to be used outside of this file.
// see https://gokit.io/examples/stringsvc.html#requests-and-responses for more detail
type _getUserRequest struct {
	First int
	User  user.User
	ID    *int
}

// _loginRequest is not to be used outside of this file.
// see https://gokit.io/examples/stringsvc.html#requests-and-responses for more detail
type _loginRequest struct {
}

// _getUserResponse is not to be used outside of this file.
// see https://gokit.io/examples/stringsvc.html#requests-and-responses for more detail
type _getUserResponse struct {
}

// _loginResponse is not to be used outside of this file.
// see https://gokit.io/examples/stringsvc.html#requests-and-responses for more detail
type _loginResponse struct {
	Body *user.User
}

// endpoints as used in https://gokit.io/examples/stringsvc.html#endpoints
func makeGetUserEndpoint(svc TestService3, opts *options.Options) endpoint.Endpoint {
	getUserEndpoint := func(ctx context.Context, request interface{}) (interface{}, error) {

		req := request.(_getUserRequest)

		resp := _getUserResponse{}
		var err error

		err = svc.GetUser(ctx, req.first, req.User, req.id)

		return resp, err
	}

	getUserMiddleware := opts.OpMiddlewares("GetUser")

	return getUserMiddleware(getUserEndpoint)
}

// endpoints as used in https://gokit.io/examples/stringsvc.html#endpoints
func makeLoginEndpoint(svc TestService3, opts *options.Options) endpoint.Endpoint {
	loginEndpoint := func(ctx context.Context, request interface{}) (interface{}, error) {

		resp := _loginResponse{}
		var err error

		resp.Body, err = svc.Login(ctx)

		return resp, err
	}

	loginMiddleware := opts.OpMiddlewares("Login")

	return loginMiddleware(loginEndpoint)
}

// HTTP transport after this

// HTTP encoders
const ct = "Content-Type"

func encodeGetUserResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
	produces := []string{}

	resp := response.(_getUserResponse)

	return nil
}

func encodeLoginResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
	produces := []string{}

	resp := response.(_loginResponse)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(ct, mt)
	enc := newEnc(w)
	if err := enc.Encode(resp.Body); err != nil {
		return err
	}

	return nil
}

// HTTP decoders
func decodeGetUserRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _getUserRequest{

		first: 10, // 10 is the default value for first

		// { bla} is the default value for User

	}

	// Extract first from query which is a int
	{
		val := ""
		_, ok := r.URL.Query()[""]
		if ok {
			val = r.URL.Query().Get("")
		}
		if true && !ok { // if required and doesn't exist throw an error
			return nil, fmt.Errorf("query parameter %q doesn't exist and is required", "")
		}
		request.first, err = strconv.Atoi(val)

		if err != nil {
			return nil, err
		}
	}

	// Extract User from body which is a user.User
	{

		if err != nil {
			return nil, err
		}
	}

	// Extract id from path which is a *int
	{
		val := mux.Vars(r)[""]
		var i int
		i, err = strconv.Atoi(val)
		if err == nil {
			request.id = &i
		}

		if err != nil {
			return nil, err
		}
	}

	consumes := []string{}

	dec, err := decoders.RequestDecoder(r, consumes)
	if err != nil {
		return nil, err
	}
	err = dec.Decode(&request.User)
	return request, err
}

func decodeLoginRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _loginRequest{}

	return request, err
}

// NewTestService3HTTPServer returns a HTTPHandler that can be used with the go std http package
func NewTestService3HTTPServer(svc TestService3, opts ...options.Option) http.Handler {
	r := mux.NewRouter()
	svcOptions := options.New()
	for _, optf := range opts {
		optf(svcOptions)
	}

	{

		getUserEndpoint := makeGetUserEndpoint(svc, svcOptions)
		getUserHandler := httptransport.NewServer(
			getUserEndpoint,
			decodeGetUserRequest,
			encodeGetUserResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/users/{id}", getUserHandler).Methods("POST")
	}

	{

		loginEndpoint := makeLoginEndpoint(svc, svcOptions)
		loginHandler := httptransport.NewServer(
			loginEndpoint,
			decodeLoginRequest,
			encodeLoginResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/login", loginHandler).Methods("GET")
	}

	return r
}
