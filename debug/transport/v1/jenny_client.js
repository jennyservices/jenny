// @flow
// Automatically generated by Jenny. DO NOT EDIT!
import matchstick from 'matchstick';
import fetch from 'cross-fetch';
import url from 'url';

type ErrorResponse = {
  wrote?: boolean
};

type Exception = {
  stacktrace: StackTrace,
  type?: string,
  value?: string
};

type ExtraInfo = {
  runtimeGOMAXPROCS: number,
  runtimeNumCPU: number,
  runtimeNumGoroutine: number,
  runtimeVersion: string,
  x_request_id: string
};

type Frame = {
  abs_path?: string,
  context_line?: string,
  filename?: string,
  function?: string,
  in_app?: boolean,
  lineno?: number,
  module?: string,
  post_context: string[],
  pre_context: string[]
};

type Header = {
  key?: string,
  values: string[]
};

type Packet = {
  event_id?: string,
  exception: Exception,
  extra: ExtraInfo,
  level?: string,
  logger?: string,
  message?: string,
  platform?: string,
  project?: string,
  server_name?: string
};

type Request = {
  body: string,
  headers?: Header[],
  method?: string,
  url?: string
};

type Response = {
  body: string,
  headers?: Header[],
  status?: number
};

type Run = {
  addr: string,
  builder: string,
  pid: number,
  runner: string
};

type Service = {
  docker?: boolean,
  healthy?: boolean,
  name?: string,
  ready?: boolean,
  swagger?: boolean,
  swagger_definition: string
};

type StackTrace = {
  frames: Frame[]
};

type Trip = {
  duration?: number,
  id?: string,
  method?: string,
  operationId?: string,
  request: Request,
  response: Response,
  status?: number,
  test?: string,
  url?: string
};

export default class DebugClient {
  constructor(baseurl: string) {
    this.baseURL = baseurl;
  }
  baseURL = '';

  async GetService(Name: string): Promise<string> {
    let pathMaker = matchstick(this.baseURL + `/services/{name}`, 'template');
    let path = pathMaker.stick({ name: Name });
    let u = url.parse(path);
    let data: string = await fetch(path);
    return data;
  }

  async GetTrip(ID: string): Promise<Trip> {
    let pathMaker = matchstick(this.baseURL + `/trips/{id}`, 'template');
    let path = pathMaker.stick({ id: ID });
    let u = url.parse(path);
    let data: Trip = await fetch(path);
    return data;
  }

  async NewError(ID: string, Pkt: Packet): Promise<ErrorResponse> {
    let pathMaker = matchstick(this.baseURL + `/api/{id}/store`, 'template');
    let path = pathMaker.stick({ id: ID, pkt: Pkt });
    let u = url.parse(path);
    let data: ErrorResponse = await fetch(path);
    return data;
  }

  async Run(): Promise<Run> {
    let pathMaker = matchstick(this.baseURL + `/run`, 'template');
    let path = pathMaker.stick({});
    let u = url.parse(path);
    let data: Run = await fetch(path);
    return data;
  }

  async Services(): Promise<Service[]> {
    let pathMaker = matchstick(this.baseURL + `/services`, 'template');
    let path = pathMaker.stick({});
    let u = url.parse(path);
    let data: Service[] = await fetch(path);
    return data;
  }

  async Trips(): Promise<Trip[]> {
    let pathMaker = matchstick(this.baseURL + `/trips`, 'template');
    let path = pathMaker.stick({});
    let u = url.parse(path);
    let data: Trip[] = await fetch(path);
    return data;
  }
}
