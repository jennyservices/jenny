// Automatically generated by Jenny. DO NOT EDIT!

// Package v1 as generated by Jenny
// Please read about it https://localhost:8080/_spec
package v1

import (
	"context"
	"net/http"

	"github.com/jennyservices/jenny/decoders"
	"github.com/jennyservices/jenny/encoders"
	"github.com/jennyservices/jenny/mime"
	"github.com/jennyservices/jenny/options"
	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
)

// HTTP transport after this

// HTTP encoders
const contentType = "Content-Type"

func encodeGetServiceResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {

	produces := []mime.Type{"application/octet-stream"}

	resp := response.(_getServiceResponse)

	statusCode := 200

	w.WriteHeader(statusCode)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(contentType, string(mt))
	enc := newEnc(w)
	if err := enc.Encode(resp.Body); err != nil {
		return err
	}

	return nil
}

func encodeGetTripResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {

	produces := []mime.Type{"application/json"}

	resp := response.(_getTripResponse)

	statusCode := 200

	w.WriteHeader(statusCode)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(contentType, string(mt))
	enc := newEnc(w)
	if err := enc.Encode(resp.Body); err != nil {
		return err
	}

	return nil
}

func encodeNewErrorResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {

	produces := []mime.Type{"application/json", "application/x-www-form-urlencoded"}

	resp := response.(_newErrorResponse)

	statusCode := 200

	w.WriteHeader(statusCode)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(contentType, string(mt))
	enc := newEnc(w)
	if err := enc.Encode(resp.Body); err != nil {
		return err
	}

	return nil
}

func encodeRunResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {

	produces := []mime.Type{"application/json", "application/x-www-form-urlencoded"}

	resp := response.(_runResponse)

	statusCode := 200

	w.WriteHeader(statusCode)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(contentType, string(mt))
	enc := newEnc(w)
	if err := enc.Encode(resp.Body); err != nil {
		return err
	}

	return nil
}

func encodeServicesResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {

	produces := []mime.Type{"application/json", "application/xml"}

	resp := response.(_servicesResponse)

	statusCode := 200

	w.WriteHeader(statusCode)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(contentType, string(mt))
	enc := newEnc(w)
	if err := enc.Encode(resp.Body); err != nil {
		return err
	}

	return nil
}

func encodeTripsResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {

	produces := []mime.Type{"application/json"}

	resp := response.(_tripsResponse)

	statusCode := 200

	w.WriteHeader(statusCode)

	newEnc, mt, err := encoders.ResponseEncoder(ctx, produces)
	if err != nil {
		return err
	}
	w.Header().Set(contentType, string(mt))
	enc := newEnc(w)
	if err := enc.Encode(resp.Body); err != nil {
		return err
	}

	return nil
}

// HTTP decoders
func decodeGetServiceRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _getServiceRequest{}

	// Extract Name from path which is a string
	{
		val := mux.Vars(r)["name"]
		request.Name = val

		if err != nil {
			return nil, err
		}
	}

	return request, err
}

func decodeGetTripRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _getTripRequest{}

	// Extract ID from path which is a string
	{
		val := mux.Vars(r)["id"]
		request.ID = val

		if err != nil {
			return nil, err
		}
	}

	return request, err
}

func decodeNewErrorRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _newErrorRequest{}

	// Extract ID from path which is a string
	{
		val := mux.Vars(r)["id"]
		request.ID = val

		if err != nil {
			return nil, err
		}
	}

	// Extract Pkt from body which is a Packet
	{

		if err != nil {
			return nil, err
		}
	}

	consumes := []mime.Type{"application/json", "application/octet-stream"}

	dec, err := decoders.RequestDecoder(r, consumes)
	if err != nil {
		return nil, err
	}
	err = dec.Decode(&request.Pkt)
	return request, err
}

func decodeRunRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _runRequest{}

	return request, err
}

func decodeServicesRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _servicesRequest{}

	return request, err
}

func decodeTripsRequest(ctx context.Context, r *http.Request) (interface{}, error) {

	var err error

	request := _tripsRequest{}

	return request, err
}

// NewDebugHTTPServer returns a HTTPHandler that can be used with the go std http package
func NewDebugHTTPServer(svc Debug, opts ...options.Option) http.Handler {
	r := mux.NewRouter()
	svcOptions := options.New()
	for _, optf := range opts {
		optf(svcOptions)
	}

	{
		svcOptions.RegisterMiddleware("GetService",
			encoders.AcceptsMustMatch([]mime.Type{
				"application/octet-stream",
			}),
		)

		getServiceEndpoint := makeGetServiceEndpoint(svc, svcOptions)
		getServiceHandler := httptransport.NewServer(
			getServiceEndpoint,
			decodeGetServiceRequest,
			encodeGetServiceResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/services/{name}", getServiceHandler).Methods("GET")
	}

	{
		svcOptions.RegisterMiddleware("GetTrip",
			encoders.AcceptsMustMatch([]mime.Type{
				"application/json",
			}),
		)

		getTripEndpoint := makeGetTripEndpoint(svc, svcOptions)
		getTripHandler := httptransport.NewServer(
			getTripEndpoint,
			decodeGetTripRequest,
			encodeGetTripResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/trips/{id}", getTripHandler).Methods("GET")
	}

	{
		svcOptions.RegisterMiddleware("NewError",
			encoders.AcceptsMustMatch([]mime.Type{
				"application/json", "application/x-www-form-urlencoded",
			}),
		)

		newErrorEndpoint := makeNewErrorEndpoint(svc, svcOptions)
		newErrorHandler := httptransport.NewServer(
			newErrorEndpoint,
			decodeNewErrorRequest,
			encodeNewErrorResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/api/{id}/store/", newErrorHandler).Methods("POST")
	}

	{
		svcOptions.RegisterMiddleware("Run",
			encoders.AcceptsMustMatch([]mime.Type{
				"application/json", "application/x-www-form-urlencoded",
			}),
		)

		runEndpoint := makeRunEndpoint(svc, svcOptions)
		runHandler := httptransport.NewServer(
			runEndpoint,
			decodeRunRequest,
			encodeRunResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/run", runHandler).Methods("GET")
	}

	{
		svcOptions.RegisterMiddleware("Services",
			encoders.AcceptsMustMatch([]mime.Type{
				"application/json", "application/xml",
			}),
		)

		servicesEndpoint := makeServicesEndpoint(svc, svcOptions)
		servicesHandler := httptransport.NewServer(
			servicesEndpoint,
			decodeServicesRequest,
			encodeServicesResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/services", servicesHandler).Methods("GET")
	}

	{
		svcOptions.RegisterMiddleware("Trips",
			encoders.AcceptsMustMatch([]mime.Type{
				"application/json",
			}),
		)

		tripsEndpoint := makeTripsEndpoint(svc, svcOptions)
		tripsHandler := httptransport.NewServer(
			tripsEndpoint,
			decodeTripsRequest,
			encodeTripsResponse,
			svcOptions.HTTPOptions()...,
		)
		r.Handle("/trips", tripsHandler).Methods("GET")
	}

	return r
}
